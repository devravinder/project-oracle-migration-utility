ext {
    // Read from environment variables, with defaults for local development
    def devDbUrl     = System.getenv('DEV_DB_URL') ?: 'jdbc:oracle:thin:@//localhost:1522/XEPDB1'
    def devDbUser     = System.getenv('DEV_DB_USER') ?: 'DEV_USER'
    def devDbPassword = System.getenv('DEV_DB_PASSWORD') ?: 'DEV_PASS'

    def localDbUrl     = System.getenv('LOCAL_DB_URL') ?: 'jdbc:oracle:thin:@//localhost:1521/XEPDB1'
    def localDbUser     = System.getenv('LOCAL_DB_USER') ?: 'LOCAL_USER'
    def localDbPassword = System.getenv('LOCAL_DB_PASSWORD') ?: 'LOCAL_PASS'

    devUrl      = devDbUrl
    devUsername = devDbUser
    devPassword = devDbPassword
    devSchema   = devDbUser

    localUrl      = localDbUrl
    localUsername = localDbUser
    localPassword = localDbPassword
    localSchema   = localDbUser

    dbDriver = 'oracle.jdbc.OracleDriver'

    changelogDir       = "$projectDir/src/main/resources/db/changelog"
    masterChangelog    = "$changelogDir/db.changelog-master.xml"
    generatedChangelog = "$changelogDir/generated/db.changelog-generated.xml"
    diffChangelog      = "$changelogDir/diff/db.changelog-diff.xml"
}

// ─────────────────────────────────────────────
// Helper: runs any Liquibase command via JavaExec
// ─────────────────────────────────────────────
def runLiquibase(List<String> args) {
    def liquibaseClasspath = configurations.liquibaseRuntime.asPath

    def cmd = new ArrayList<String>()
    cmd.add('java')
    cmd.add('--add-opens=java.base/java.lang=ALL-UNNAMED')
    cmd.add('--add-opens=java.base/java.nio=ALL-UNNAMED')
    cmd.add('-cp')
    cmd.add(liquibaseClasspath)
    cmd.add('liquibase.integration.commandline.LiquibaseCommandLine')
    for (String arg : args) {
        cmd.add(arg)
    }

    println "  Running Liquibase: ${args.last()}"
    println ""

    def process = new ProcessBuilder(cmd)
            .redirectErrorStream(true)
            .directory(project.projectDir)
            .start()

    def reader = new BufferedReader(new InputStreamReader(process.inputStream))
    String line
    while ((line = reader.readLine()) != null) {
        println "  [liquibase] $line"
    }

    def exitCode = process.waitFor()
    if (exitCode != 0) {
        throw new GradleException("Liquibase failed with exit code: $exitCode")
    }
}

// ═══════════════════════════════════════════════════════════════
//  STEP 1 — generateChangelogFromDev
// ═══════════════════════════════════════════════════════════════
tasks.register('generateChangelogFromDev') {
    group       = 'Liquibase - 1. Generate'
    description = 'STEP 1: Connect to DEV DB and generate XML changelog for all schema objects'

    doFirst {
        println ""
        println "╔══════════════════════════════════════════════════════════╗"
        println "║  STEP 1 — Generate Schema Changelog from DEV DB         ║"
        println "╚══════════════════════════════════════════════════════════╝"
        println "  Source : ${project.devUrl}"
        println "  Schema : ${project.devSchema}"
        println "  Output : ${project.generatedChangelog}"
        println ""
        file("${project.changelogDir}/generated").mkdirs()
    }

    doLast {
        runLiquibase([
                "--url=${project.devUrl}",
                "--username=${project.devUsername}",
                "--password=${project.devPassword}",
                "--driver=${project.dbDriver}",
                "--defaultSchemaName=${project.devSchema}",
                "--changelogFile=${project.generatedChangelog}",
                "--diffTypes=tables,columns,indexes,foreignkeys,primarykeys,uniqueconstraints,sequences,views,data",
                "--overwriteOutputFile=true",
                "--logLevel=info",
                "generateChangelog"
        ])

        println ""
        println "  ✔ Schema changelog written to:"
        println "    ${project.generatedChangelog}"
        println ""
        println "  ⚠ Stored procedures/functions are NOT included here."
        println "    Run STEP 2: ./gradlew extractProcsFromDev"
        println ""
    }
}

tasks.register('fixChangelogSchemaRefs') {
    group       = 'Liquibase - 1. Generate'
    description = 'Fixes schema refs and removes system-generated constraint names from generated changelog'

    mustRunAfter 'generateChangelogFromDev'

    doLast {
        def generatedFile = file(project.generatedChangelog)

        if (!generatedFile.exists()) {
            throw new GradleException("Generated changelog not found: ${project.generatedChangelog}")
        }

        println ""
        println "  Fixing generated changelog..."

        def content = generatedFile.text

        content = content.replaceAll(
                "${project.devSchema.toUpperCase()}\\.(SEQ_[A-Z_]+\\.NEXTVAL)",
                '$1'
        )
        content = content.replaceAll("${project.devSchema.toUpperCase()}\\.", '')
        content = content.replaceAll("\"${project.devSchema.toUpperCase()}\"\\.", '')
        content = content.replaceAll(/(?i)(constraintName|primaryKeyName|uniqueConstraintName)="SYS_C\d+"/, '')
        content = content.replaceAll(/CONSTRAINT SYS_C\d+\s+/, '')

        // Remove virtual column data from inserts, as it cannot be inserted directly.
        content = content.replaceAll(/<column name="TOTAL_AMOUNT"[^>]*\/>\r?\n?/, '')

        generatedFile.text = content

        println "  ✔ Fixed schema refs and removed SYS_C constraint names"
        println "    ${project.generatedChangelog}"
        println ""
    }
}

tasks.register('reorderChangelog') {
    group       = 'Liquibase - 1. Generate'
    description = 'Reorders generated changelog: sequences first, then tables, then everything else'

    mustRunAfter 'fixChangelogSchemaRefs'

    doLast {
        def generatedFile = file(project.generatedChangelog)

        if (!generatedFile.exists()) {
            throw new GradleException("Generated changelog not found: ${project.generatedChangelog}")
        }

        println ""
        println "  Reordering changesets: sequences → tables → views → indexes → constraints..."

        def content = generatedFile.text
        if (!content.contains('<changeSet')) {
            println "  No changesets found in ${generatedFile.name}, skipping reorder."
            return
        }
        def header = content.substring(0, content.indexOf('<changeSet'))
        def footer = '</databaseChangeLog>'

        def changeSetPattern = ~/(?s)<changeSet[^>]*>.*?<\/changeSet>/
        def changeSets = []
        def matcher = changeSetPattern.matcher(content)
        while (matcher.find()) {
            changeSets << matcher.group()
        }

        def sequences   = changeSets.findAll { it.contains('<createSequence') }
        def tables      = changeSets.findAll { it.contains('<createTable') }
        def views       = changeSets.findAll { it.contains('<createView') }
        def indexes     = changeSets.findAll { it.contains('<createIndex') }
        def addFKs      = changeSets.findAll { it.contains('<addForeignKeyConstraint') }
        def addPKs      = changeSets.findAll { it.contains('<addPrimaryKey') }
        def addUnique   = changeSets.findAll { it.contains('<addUniqueConstraint') }

        def uniqueIndexNames = indexes.findAll { it.contains('unique="true"') }
            .collect { cs ->
                def indexMatcher = (cs =~ /<createIndex indexName="([^"]+)"/)
                return indexMatcher.find() ? indexMatcher.group(1) : null
            }.findAll { it != null }

        def filteredAddUnique = addUnique.findAll { cs ->
            def constraintMatcher = (cs =~ /<addUniqueConstraint [^>]*forIndexName="([^"]+)"/)
            def forIndex = constraintMatcher.find() ? constraintMatcher.group(1) : ''
            !uniqueIndexNames.contains(forIndex)
        }
        def removedCount = addUnique.size() - filteredAddUnique.size()
        
        def others      = changeSets.findAll { cs ->
            !sequences.contains(cs) &&
                    !tables.contains(cs)    &&
                    !views.contains(cs)     &&
                    !indexes.contains(cs)   &&
                    !addFKs.contains(cs)    &&
                    !addPKs.contains(cs)    &&
                    !addUnique.contains(cs)
        }

        def inserts = others.findAll { it.contains('<insert tableName=') }
        others = others.findAll { !it.contains('<insert tableName=') }

        def tableInsertOrder = ['ROLES', 'USERS', 'PRODUCTS', 'ORDERS', 'AUDIT_LOG']
        def sortedInserts = inserts.sort { cs1, cs2 ->
            def table1 = (cs1 =~ /<insert tableName="([^"]+)"/)[0][1]
            def table2 = (cs2 =~ /<insert tableName="([^"]+)"/)[0][1]
            def index1 = tableInsertOrder.indexOf(table1)
            def index2 = tableInsertOrder.indexOf(table2)
            index1 <=> index2
        }

        def ordered = sequences + tables + views + indexes + addPKs + filteredAddUnique + addFKs + sortedInserts + others
        def newContent = header + ordered.join('\n\n') + '\n\n' + footer
        generatedFile.text = newContent

        println "  ✔ Reordered: ${sequences.size()} sequences, ${tables.size()} tables, " +
                "${views.size()} views, ${indexes.size()} indexes, " +
                "${sortedInserts.size()} inserts, ${addFKs.size()} FKs, ${others.size()} others"
        if (removedCount > 0) {
            println "  ✔ Removed ${removedCount} redundant <addUniqueConstraint> changesets already covered by unique indexes"
        }
        println ""
    }
}

// ═══════════════════════════════════════════════════════════════
//  STEP 2 — extractProcsFromDev
// ═══════════════════════════════════════════════════════════════
tasks.register('extractProcsFromDev') {
    group       = 'Liquibase - 1. Generate'
    description = 'STEP 2: Extract stored procedures/functions/triggers from DEV DB via JDBC + DBMS_METADATA'

    mustRunAfter 'generateChangelogFromDev'

    doFirst {
        println ""
        println "╔══════════════════════════════════════════════════════════╗"
        println "║  STEP 2 — Extract Stored Procedures from DEV DB         ║"
        println "╚══════════════════════════════════════════════════════════╝"
        println "  Source : ${project.devUrl}"
        println "  Schema : ${project.devSchema}"
        println "  Output : ${project.changelogDir}/procedures/"
        println ""
    }

    doLast {
        def outputDir = file("${project.changelogDir}/procedures")
        outputDir.mkdirs()

        def urls           = configurations.liquibaseRuntime.collect { it.toURI().toURL() }
        def urlClassLoader = new URLClassLoader(urls.toArray(new URL[0]) as URL[], Thread.currentThread().contextClassLoader)
        def driverClass    = Class.forName('oracle.jdbc.OracleDriver', true, urlClassLoader)

        def props = new Properties()
        props.setProperty('user',     project.devUsername)
        props.setProperty('password', project.devPassword)

        println "  Connecting to DEV DB..."
        def conn = driverClass.getDeclaredConstructor().newInstance().connect(project.devUrl, props)
        println "  Connected ✔"
        println ""

        try {
            def objectTypes = ['TYPE', 'FUNCTION', 'PROCEDURE', 'PACKAGE', 'PACKAGE BODY', 'TRIGGER']
            def allSqlFiles = []

            objectTypes.each { objType ->
                println "  Scanning [$objType]..."
                def stmt = conn.prepareStatement("""
                    SELECT OBJECT_NAME
                    FROM ALL_OBJECTS
                    WHERE OBJECT_TYPE = ?
                    AND OWNER = UPPER(?)
                    ORDER BY OBJECT_NAME
                """)
                stmt.setString(1, objType)
                stmt.setString(2, project.devSchema)
                def rs = stmt.executeQuery()

                int count = 0
                while (rs.next()) {
                    def objName = rs.getString('OBJECT_NAME')
                    def ddlStmt = conn.prepareStatement(
                            "SELECT DBMS_METADATA.GET_DDL(?, ?, UPPER(?)) AS DDL_TEXT FROM DUAL"
                    )
                    ddlStmt.setString(1, objType.replace(' ', '_'))
                    ddlStmt.setString(2, objName)
                    ddlStmt.setString(3, project.devSchema)

                    try {
                        def ddlRs = ddlStmt.executeQuery()
                        if (ddlRs.next()) {
                            def ddl = ddlRs.getClob('DDL_TEXT')?.characterStream?.text ?: ''
                            if (ddl) {
                                ddl = ddl.replaceAll("\"${project.devSchema.toUpperCase()}\"\\.", '')
                                        .replaceAll("${project.devSchema.toUpperCase()}\\.", '')
                                        .trim()
                                def safeType = objType.toLowerCase().replace(' ', '_')
                                def fileName = "${safeType}_${objName.toLowerCase()}.sql"
                                new File(outputDir, fileName).text = ddl + "\n/\n"
                                allSqlFiles << [type: objType, name: objName, file: fileName]
                                println "    ✔ ${objType.padRight(12)} ${objName}"
                                count++
                            }
                        }
                        ddlRs.close()
                    } catch (Exception ex) {
                        println "    ⚠ Could not extract [$objType] $objName: ${ex.message}"
                    }
                    ddlStmt.close()
                }
                rs.close()
                stmt.close()
                println "    Total: $count"
                println ""
            }

            buildProceduresChangelog(allSqlFiles, project.changelogDir)
            println "  ✔ Procedures changelog written:"
            println "    ${project.changelogDir}/generated/db.changelog-procedures.xml"

        } finally {
            conn.close()
            println "  Connection closed."
        }
        println ""
    }
}

def buildProceduresChangelog(List sqlFiles, String clDir) {
    def sb = new StringBuilder()
    sb << """<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        https://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.25.xsd">\n\n"""

    if (sqlFiles.isEmpty()) {
        sb << "    <!-- No stored procedures/functions found in source schema -->\n"
    } else {
        sqlFiles.eachWithIndex { obj, idx ->
            sb << """    <!-- ${obj.type}: ${obj.name} -->
    <changeSet id="procs-${String.format('%04d', idx + 1)}" author="liquibase-extract" runOnChange="true">
        <sqlFile path="db/changelog/procedures/${obj.file}"
                 relativeToChangelogFile="false"
                 splitStatements="false"
                 endDelimiter="/"
                 stripComments="false"/>
        <rollback/>
    </changeSet>\n\n"""
        }
    }
    sb << "</databaseChangeLog>\n"
    file("$clDir/generated/db.changelog-procedures.xml").text = sb.toString()
}

tasks.register('createMasterChangelog') {
    group       = 'Liquibase - 1. Generate'
    description = 'Creates db.changelog-master.xml if it does not exist'

    doLast {
        def masterFile = file(project.masterChangelog)
        if (masterFile.exists()) {
            println "  ✔ Master changelog already exists — skipping."
            return
        }

        masterFile.parentFile.mkdirs()
        masterFile.text = """<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
        https://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.25.xsd">

    <!-- 1. Schema: tables, views, sequences, indexes, constraints -->
    <include file="db/changelog/generated/db.changelog-generated.xml"
             relativeToChangelogFile="false"/>

    <!-- 2. Stored procedures, functions, packages, triggers -->
    <include file="db/changelog/generated/db.changelog-procedures.xml"
             relativeToChangelogFile="false"/>

</databaseChangeLog>
"""
        println "  ✔ Created: ${masterFile.path}"
    }
}

// ═══════════════════════════════════════════════════════════════
//  STEP 3 — applyChangelogToLocal
// ═══════════════════════════════════════════════════════════════
tasks.register('applyChangelogToLocal') {
    group       = 'Liquibase - 2. Apply'
    description = 'STEP 3: Apply master changelog to LOCAL Docker Oracle DB (idempotent)'

    mustRunAfter 'generateChangelogFromDev', 'extractProcsFromDev'

    doFirst {
        println ""
        println "╔══════════════════════════════════════════════════════════╗"
        println "║  STEP 3 — Apply Changelogs to LOCAL Docker DB           ║"
        println "╚══════════════════════════════════════════════════════════╝"
        println "  Target    : ${project.localUrl}"
        println "  Schema    : ${project.localSchema}"
        println "  Changelog : ${project.masterChangelog}"
        println ""
        println "  Only NEW changesets will be applied."
        println "  Already-applied changesets are skipped automatically."
        println ""
    }

    doLast {
        runLiquibase([
                "--url=${project.localUrl}",
                "--username=${project.localUsername}",
                "--password=${project.localPassword}",
                "--driver=${project.dbDriver}",
                "--defaultSchemaName=${project.localSchema}",
                "--searchPath=${project.changelogDir}/../..",
                "--changelogFile=db/changelog/db.changelog-master.xml",

                "--logLevel=info",
                "update"
        ])

        println ""
        println "  ✔ Changelogs applied — LOCAL DB is in sync with DEV DB!"
        println ""
    }
}

// ═══════════════════════════════════════════════════════════════
//  UTILITIES
// ═══════════════════════════════════════════════════════════════
tasks.register('pendingChanges') {
    group       = 'Liquibase - 3. Verify'
    description = 'Show changesets not yet applied to LOCAL DB (read-only)'

    doLast {
        runLiquibase([
                "--url=${project.localUrl}",
                "--username=${project.localUsername}",
                "--password=${project.localPassword}",
                "--driver=${project.dbDriver}",
                "--defaultSchemaName=${project.localSchema}",
                "--changelogFile=${project.masterChangelog}",
                "status"
        ])
    }
}

tasks.register('diffDatabases') {
    group       = 'Liquibase - 3. Verify'
    description = 'Compare DEV DB vs LOCAL DB. Writes diff changelog. Nothing is changed.'

    doFirst {
        file("${project.changelogDir}/diff").mkdirs()
    }

    doLast {
        runLiquibase([
                "--url=${project.localUrl}",
                "--username=${project.localUsername}",
                "--password=${project.localPassword}",
                "--referenceUrl=${project.devUrl}",
                "--referenceUsername=${project.devUsername}",
                "--referencePassword=${project.devPassword}",
                "--changelogFile=${project.diffChangelog}",
                "diffChangelog"
        ])
    }
}

tasks.register('validateChangelogs') {
    group       = 'Liquibase - 3. Verify'
    description = 'Validate master changelog XML integrity against LOCAL DB (read-only)'
    
    doLast {
        runLiquibase([
                "--url=${project.localUrl}",
                "--username=${project.localUsername}",
                "--password=${project.localPassword}",
                "--driver=${project.dbDriver}",
                "--defaultSchemaName=${project.localSchema}",
                "--changelogFile=${project.masterChangelog}",
                "validate"
        ])
    }
}

tasks.register('rollbackLastChangeset') {
    group       = 'Liquibase - 4. Rollback'
    description = 'Rollback last applied changeset on LOCAL DB. Use -ProllbackCount=N for N changesets.'

    doLast {
        def count = project.findProperty('rollbackCount') ?: '1'
        runLiquibase([
                "--url=${project.localUrl}",
                "--username=${project.localUsername}",
                "--password=${project.localPassword}",
                "--driver=${project.dbDriver}",
                "--defaultSchemaName=${project.localSchema}",
                "--changelogFile=${project.masterChangelog}",
                "rollbackCount",
                count.toString()
        ])
    }
}

tasks.register('cleanLocalDb') {
    group       = 'Liquibase - 4. Rollback'
    description = 'Drops all objects from the LOCAL schema to allow for a clean migration run'

    doFirst {
        println ""
        println "╔══════════════════════════════════════════════════════════╗"
        println "║  CLEAN — Drop All Objects from LOCAL DB Schema          ║"
        println "╚══════════════════════════════════════════════════════════╝"
        println "  Target : ${project.localUrl}"
        println "  Schema : ${project.localSchema}"
        println ""
        println "  ⚠ WARNING: This will permanently delete all objects and data"
        println "    in the '${project.localSchema}' schema."
        println ""
    }

    doLast {
        def urls           = configurations.liquibaseRuntime.collect { it.toURI().toURL() }
        def urlClassLoader = new URLClassLoader(urls.toArray(new URL[0]) as URL[], Thread.currentThread().contextClassLoader)
        def driverClass    = Class.forName('oracle.jdbc.OracleDriver', true, urlClassLoader)

        def props = new Properties()
        props.setProperty('user',     project.localUsername)
        props.setProperty('password', project.localPassword)

        println "  Connecting to LOCAL DB..."
        def conn = driverClass.getDeclaredConstructor().newInstance().connect(project.localUrl, props)
        println "  Connected ✔"
        println ""

        try {
            def dropStatements = [
                "BEGIN FOR c IN (SELECT 'DROP ' || object_type || ' ' || object_name || CASE WHEN object_type = 'TABLE' THEN ' CASCADE CONSTRAINTS' ELSE '' END AS stmt FROM user_objects WHERE object_type IN ('TABLE', 'VIEW', 'PACKAGE', 'PROCEDURE', 'FUNCTION', 'SEQUENCE', 'TRIGGER', 'TYPE')) LOOP EXECUTE IMMEDIATE c.stmt; END LOOP; END;",
                "PURGE RECYCLEBIN"
            ]

            def stmt = conn.createStatement()
            println "  Dropping objects from schema '${project.localSchema}'..."
            dropStatements.each { sql ->
                try {
                    stmt.execute(sql)
                } catch (Exception e) {
                    println "    (Ignoring: ${e.message.split('\\n')[0]})"
                }
            }
            println "  ✔ Schema cleaned."
        } finally {
            conn.close()
            println "  Connection closed."
        }
        println ""
    }
}

// ═══════════════════════════════════════════════════════════════
//  FULL PIPELINE
// ═══════════════════════════════════════════════════════════════
tasks.register('fullMigration') {
    group       = 'Liquibase - Full Pipeline'
    description = 'Runs the full migration: clean → generate → fix → reorder → extract → create → apply'
    
    dependsOn 'cleanLocalDb', 'generateChangelogFromDev', 'fixChangelogSchemaRefs', 'reorderChangelog', 'extractProcsFromDev', 'createMasterChangelog', 'applyChangelogToLocal'

    doFirst {
        println "╔══════════════════════════════════════════════════════════╗"
        println "║           FULL MIGRATION PIPELINE                       ║"
        println "╚══════════════════════════════════════════════════════════╝"
    }
    
    doLast {
        println ""
        println "╔══════════════════════════════════════════════════════════╗"
        println "║  ✔  MIGRATION COMPLETE                                  ║"
        println "╚══════════════════════════════════════════════════════════╝"
    }
}

tasks.named('fixChangelogSchemaRefs') { mustRunAfter 'generateChangelogFromDev' }
tasks.named('reorderChangelog')       { mustRunAfter 'fixChangelogSchemaRefs' }
tasks.named('extractProcsFromDev')    { mustRunAfter 'reorderChangelog' }
tasks.named('createMasterChangelog')  { mustRunAfter 'extractProcsFromDev' }
tasks.named('applyChangelogToLocal')  { mustRunAfter 'createMasterChangelog' }
tasks.named('fullMigration').configure {
    mustRunAfter 'cleanLocalDb'
    tasks.findByName('generateChangelogFromDev').mustRunAfter('cleanLocalDb')
}
